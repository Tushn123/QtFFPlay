# 视频同步音频 - ffplay 实现分析

## 概述

在 ffplay 中，当以音频为主时钟 (`AV_SYNC_AUDIO_MASTER`) 时，视频需要同步到音频。核心思想是：

1. **决策轨**：通过系统时间和理论播放时间的对比，决定当前帧是"播放"还是"等待"
2. **反馈轨**：通过实际播放的视频帧更新视频时钟，为下次决策提供依据

两者形成闭环，实现视频平滑追踪音频。

---

## 核心数据结构

### Clock 结构体

```c
typedef struct Clock {
    double pts;           // 当前时钟的 PTS 值（秒）
    double pts_drift;     // pts 与系统时间的差值，用于连续计算当前时间
    double last_updated;  // 上次更新时钟的系统时间
    double speed;         // 播放速度
    int serial;           // 时钟的序列号，用于判断数据有效性
    int paused;           // 是否暂停
    int *queue_serial;    // 指向对应 PacketQueue 的 serial
} Clock;
```

### VideoState 中的关键字段

```c
typedef struct VideoState {
    // 三个时钟
    Clock audclk;         // 音频时钟 (主时钟)
    Clock vidclk;         // 视频时钟 (从时钟)
    Clock extclk;         // 外部时钟
    
    // 视频同步相关
    double frame_timer;   // 上一帧显示的系统时间
    double frame_last_filter_delay;
    
    // 队列
    FrameQueue pictq;     // 视频帧队列
    PacketQueue videoq;   // 视频包队列
    
    // ...
} VideoState;
```

---

## 关键变量说明

| 变量 | 类型 | 说明 |
|------|------|------|
| `audclk` | Clock | 音频时钟，作为主时钟，由音频播放回调更新 |
| `vidclk` | Clock | 视频时钟，从时钟，由视频显示时更新 |
| `frame_timer` | double | 上一帧"应该"显示的系统时间 |
| `time` | double | 当前系统时间 (`av_gettime_relative() / 1000000.0`) |
| `delay` | double | 当前帧应该显示的时长（经过同步调整） |
| `diff` | double | 视频时钟与主时钟的差值 (`vidclk - audclk`) |
| `last_duration` | double | 上一帧到当前帧的理论时长 |

---

## 同步流程图

### 整体架构

```
┌─────────────────────────────────────────────────────────────────────┐
│                    视频同步音频 - 双轨机制                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  第一轨：决策轨 - "播还是不播"                                │  │
│  │  ─────────────────────────────────────────────────────────────│  │
│  │                                                               │  │
│  │  输入:                                                        │  │
│  │  • frame_timer (上一帧显示的系统时间)                         │  │
│  │  • delay = compute_target_delay(last_duration)                │  │
│  │       ↑                                                       │  │
│  │       └── 参考 audclk 与 vidclk 的差值调整                    │  │
│  │                                                               │  │
│  │  判断:                                                        │  │
│  │  if (time < frame_timer + delay)                              │  │
│  │      → 还没到时间，等待 (remaining_time)                      │  │
│  │  else                                                         │  │
│  │      → 到时间了，显示下一帧                                   │  │
│  │                                                               │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                              │                                       │
│                              ▼ (决定显示后)                          │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  第二轨：反馈轨 - "更新视频时钟"                              │  │
│  │  ─────────────────────────────────────────────────────────────│  │
│  │                                                               │  │
│  │  update_video_pts(is, vp->pts, vp->serial)                    │  │
│  │      │                                                        │  │
│  │      ▼                                                        │  │
│  │  set_clock(&is->vidclk, pts, serial)                          │  │
│  │      │                                                        │  │
│  │      └── vidclk 现在反映"当前实际显示帧"的时间                │  │
│  │                                                               │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                              │                                       │
│                              ▼                                       │
│                    ┌─────────────────┐                              │
│                    │  形成闭环反馈   │                              │
│                    └─────────────────┘                              │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

### 闭环反馈流程

```
         ┌──────────────────────────────────────────────┐
         │                                              │
         ▼                                              │
  ┌─────────────┐    diff = vidclk - audclk    ┌───────┴─────┐
  │   audclk    │◄─────────────────────────────│   vidclk    │
  │  (master)   │                              │  (slave)    │
  └─────────────┘                              └─────────────┘
         │                                              ▲
         │ diff                                         │
         ▼                                              │
  ┌─────────────────────────┐                          │
  │  compute_target_delay   │                          │
  │  根据 diff 调整 delay   │                          │
  │  • diff > 0: 视频快了   │                          │
  │    → delay 增大 (等)    │                          │
  │  • diff < 0: 视频慢了   │                          │
  │    → delay 减小 (追)    │                          │
  └─────────────────────────┘                          │
         │                                              │
         │ delay                                        │
         ▼                                              │
  ┌─────────────────────────┐                          │
  │  time < frame_timer +   │──No──► 显示帧 ──────────►│
  │        delay ?          │       update_video_pts   │
  └─────────────────────────┘       更新 vidclk        │
         │                                              │
        Yes                                             │
         │                                              │
         ▼                                              │
      等待 remaining_time                               │
         │                                              │
         └──────────────────────────────────────────────┘
```

---

## 关键函数分析

### 1. get_clock - 获取时钟当前值

```c
static double get_clock(Clock *c)
{
    // 检查 serial 是否匹配，不匹配返回 NAN
    if (*c->queue_serial != c->serial)
        return NAN;
    if (c->paused) {
        return c->pts;  // 暂停时返回固定值
    } else {
        double time = av_gettime_relative() / 1000000.0;
        // 通过 pts_drift 计算当前时间：pts_drift + time
        // 考虑播放速度：减去 (time - last_updated) * (1.0 - speed)
        return c->pts_drift + time - (time - c->last_updated) * (1.0 - c->speed);
    }
}
```

**说明**：
- `pts_drift = pts - last_updated_time`，记录了 PTS 与系统时间的差值
- 通过 `pts_drift + current_time` 可以计算出当前应该的 PTS
- 这样在两次 set_clock 之间也能获取准确的时钟值

### 2. set_clock - 设置时钟

```c
static void set_clock_at(Clock *c, double pts, int serial, double time)
{
    c->pts = pts;
    c->last_updated = time;
    c->pts_drift = c->pts - time;  // 记录差值
    c->serial = serial;
}

static void set_clock(Clock *c, double pts, int serial)
{
    double time = av_gettime_relative() / 1000000.0;
    set_clock_at(c, pts, serial, time);
}
```

### 3. get_master_clock - 获取主时钟

```c
static double get_master_clock(VideoState *is)
{
    double val;

    switch (get_master_sync_type(is)) {
        case AV_SYNC_VIDEO_MASTER:
            val = get_clock(&is->vidclk);
            break;
        case AV_SYNC_AUDIO_MASTER:
            val = get_clock(&is->audclk);  // 音频同步时返回音频时钟
            break;
        default:
            val = get_clock(&is->extclk);
            break;
    }
    return val;
}
```

### 4. compute_target_delay - 计算目标延迟（核心同步函数）

```c
static double compute_target_delay(double delay, VideoState *is)
{
    double sync_threshold, diff = 0;

    /* 只有当不是以视频为主时钟时才需要同步 */
    if (get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER) {
        /* 计算视频时钟与主时钟的差值 */
        diff = get_clock(&is->vidclk) - get_master_clock(is);

        /* 计算同步阈值：在 [40ms, 100ms] 范围内，与 delay 相关 */
        sync_threshold = FFMAX(AV_SYNC_THRESHOLD_MIN, 
                               FFMIN(AV_SYNC_THRESHOLD_MAX, delay));
        
        if (!isnan(diff) && fabs(diff) < AV_NOSYNC_THRESHOLD) {
            if (diff <= -sync_threshold)
                // 视频慢了，减小 delay（加速追赶）
                // 最小为 0（立即显示）
                delay = FFMAX(0, delay + diff);
            else if (diff >= sync_threshold && delay > AV_SYNC_FRAMEDUP_THRESHOLD)
                // 视频快了很多，且 delay 较大，适度增加 delay
                delay = delay + diff;
            else if (diff >= sync_threshold)
                // 视频快了，delay 翻倍（等待音频）
                delay = 2 * delay;
        }
    }

    av_log(NULL, AV_LOG_TRACE, "video: delay=%0.3f A-V=%f\n", delay, -diff);

    return delay;
}
```

**同步阈值常量**：
```c
#define AV_SYNC_THRESHOLD_MIN 0.04   // 最小同步阈值 40ms
#define AV_SYNC_THRESHOLD_MAX 0.1    // 最大同步阈值 100ms
#define AV_SYNC_FRAMEDUP_THRESHOLD 0.1  // 帧重复阈值
#define AV_NOSYNC_THRESHOLD 10.0     // 超过此值不同步
```

**delay 调整逻辑图**：

```
                        diff (vidclk - audclk)
    ◄───────────────────────┼───────────────────────►
   视频慢                   0                   视频快
    
    ════════════╪═══════════╪═══════════╪════════════
               -threshold   0       +threshold
    
    区间1        │   区间2   │   区间3   │   区间4
    diff<-th    │ -th~0    │  0~+th   │  diff>+th
    ────────────┼──────────┼──────────┼────────────
    delay=      │          │          │ delay=
    max(0,      │ 不调整   │ 不调整   │ 2*delay 或
    delay+diff) │ (在容忍  │ (在容忍  │ delay+diff
    (加速追赶)  │  范围内)  │  范围内) │ (减速等待)
```

### 5. video_refresh - 视频刷新主函数

```c
static void video_refresh(void *opaque, double *remaining_time)
{
    // ... 省略部分代码 ...

retry:
    if (frame_queue_nb_remaining(&is->pictq) == 0) {
        // 没有可显示的帧
    } else {
        double last_duration, duration, delay;
        Frame *vp, *lastvp;

        /* 获取上一帧和当前帧 */
        lastvp = frame_queue_peek_last(&is->pictq);
        vp = frame_queue_peek(&is->pictq);

        /* serial 不一致则丢弃 */
        if (vp->serial != is->videoq.serial) {
            frame_queue_next(&is->pictq);
            goto retry;
        }

        /* seek 后重置 frame_timer */
        if (lastvp->serial != vp->serial)
            is->frame_timer = av_gettime_relative() / 1000000.0;

        /* 暂停状态直接显示当前帧 */
        if (is->paused)
            goto display;

        /* 计算上一帧的显示时长 */
        last_duration = vp_duration(is, lastvp, vp);
        
        /* 核心：计算经过同步调整的 delay */
        delay = compute_target_delay(last_duration, is);

        time = av_gettime_relative() / 1000000.0;
        
        /* 还没到显示时间，设置等待时间 */
        if (time < is->frame_timer + delay) {
            *remaining_time = FFMIN(is->frame_timer + delay - time, *remaining_time);
            goto display;
        }

        /* 更新 frame_timer */
        is->frame_timer += delay;
        
        /* 防止 frame_timer 落后太多 */
        if (delay > 0 && time - is->frame_timer > AV_SYNC_THRESHOLD_MAX)
            is->frame_timer = time;

        /* 更新视频时钟 */
        SDL_LockMutex(is->pictq.mutex);
        if (!isnan(vp->pts))
            update_video_pts(is, vp->pts, vp->pos, vp->serial);
        SDL_UnlockMutex(is->pictq.mutex);

        /* 判断是否需要丢帧 */
        if (frame_queue_nb_remaining(&is->pictq) > 1) {
            Frame *nextvp = frame_queue_peek_next(&is->pictq);
            duration = vp_duration(is, vp, nextvp);
            if (!is->step && 
                (framedrop > 0 || (framedrop && get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) && 
                time > is->frame_timer + duration) {
                is->frame_drops_late++;
                frame_queue_next(&is->pictq);
                goto retry;
            }
        }

        // ... 字幕处理 ...

        /* 帧出队 */
        frame_queue_next(&is->pictq);
        is->force_refresh = 1;

        if (is->step && !is->paused)
            stream_toggle_pause(is);
    }
    
display:
    /* 显示画面 */
    if (!display_disable && is->force_refresh && 
        is->show_mode == SHOW_MODE_VIDEO && is->pictq.rindex_shown)
        video_display(is);
}
```

### 6. update_video_pts - 更新视频时钟

```c
static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {
    /* 更新视频时钟 */
    set_clock(&is->vidclk, pts, serial);
    /* 同步外部时钟到视频时钟 */
    sync_clock_to_slave(&is->extclk, &is->vidclk);
}
```

### 7. vp_duration - 计算帧时长

```c
static double vp_duration(VideoState *is, Frame *vp, Frame *nextvp) {
    if (vp->serial == nextvp->serial) {
        double duration = nextvp->pts - vp->pts;
        if (isnan(duration) || duration <= 0 || duration > is->max_frame_duration)
            return vp->duration;  // 使用帧自带的 duration
        else
            return duration;      // 使用实际 PTS 差
    } else {
        return 0.0;  // serial 不同，返回 0
    }
}
```

---

## frame_timer 重置时机

| 时机 | 触发条件 | 新值 |
|------|----------|------|
| **程序启动** | `av_mallocz(VideoState)` | `0` |
| **Seek 后** | `lastvp->serial != vp->serial` | 当前系统时间 |
| **时间漂移过大** | `time - frame_timer > AV_SYNC_THRESHOLD_MAX` | 当前系统时间 |
| **暂停恢复** | `stream_toggle_pause` | 补偿调整 |

---

## 时间线示意

```
┌─────────────────────────────────────────────────────────────────────┐
│                    时间线关系                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  系统时间轴 (time):                                                 │
│  ────────────────────────────────────────────────────────►          │
│  0      1      2      3      4      5      6      7                 │
│                                                                      │
│  frame_timer 演进:                                                  │
│  [0]────[1.033]────[2.066]────[3.099]────►                          │
│    +delay  +delay    +delay    +delay                               │
│                                                                      │
│  视频 PTS 时间轴:                                                   │
│  ────────────────────────────────────────────────────────►          │
│  0    0.033  0.066  0.099  0.132  ...                               │
│  帧0   帧1    帧2    帧3    帧4                                     │
│                                                                      │
│  音频 PTS 时间轴 (主时钟):                                          │
│  ════════════════════════════════════════════════════════►          │
│  持续播放，通过 sdl_audio_callback 更新 audclk                      │
│                                                                      │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 同步效果

### 视频比音频快

```
diff = vidclk - audclk > sync_threshold

处理: delay = 2 * delay (或 delay + diff)
效果: 当前帧显示更长时间，等待音频追上
```

### 视频比音频慢

```
diff = vidclk - audclk < -sync_threshold

处理: delay = max(0, delay + diff)  // diff 为负，实际减小 delay
效果: 当前帧尽快显示，追赶音频

如果还是追不上 (time > frame_timer + duration):
    丢帧 (frame_drops_late++)
```

### 在容忍范围内

```
|diff| < sync_threshold

处理: delay 不调整
效果: 正常播放
```

---

## 丢帧机制

### 早期丢帧 (解码后立即判断)

```c
// video_thread 中
if (framedrop > 0 || (framedrop && get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) {
    if (frame->pts != AV_NOPTS_VALUE) {
        double diff = dpts - get_master_clock(is);
        if (!isnan(diff) && fabs(diff) < AV_NOSYNC_THRESHOLD &&
            diff - is->frame_last_filter_delay < 0 &&
            is->viddec.pkt_serial == is->vidclk.serial &&
            is->videoq.nb_packets) {
            is->frame_drops_early++;
            av_frame_unref(frame);
            got_picture = 0;  // 丢弃，不入队
        }
    }
}
```

### 晚期丢帧 (显示时判断)

```c
// video_refresh 中
if (frame_queue_nb_remaining(&is->pictq) > 1) {
    Frame *nextvp = frame_queue_peek_next(&is->pictq);
    duration = vp_duration(is, vp, nextvp);
    if (!is->step && 
        (framedrop > 0 || (framedrop && get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) && 
        time > is->frame_timer + duration) {
        is->frame_drops_late++;
        frame_queue_next(&is->pictq);
        goto retry;  // 丢弃当前帧，尝试下一帧
    }
}
```

---

## 总结

ffplay 的视频同步音频机制通过以下设计实现：

1. **双轨机制**：
   - 决策轨：`frame_timer + delay` vs `time` 决定播放时机
   - 反馈轨：`update_video_pts` 更新视频时钟

2. **渐进式调整**：
   - 通过调整 delay 实现平滑同步
   - 避免突兀的跳帧或重复

3. **自适应丢帧**：
   - 早期丢帧：解码后立即判断
   - 晚期丢帧：显示时判断
   - 保证在严重落后时能追上音频

4. **容错处理**：
   - serial 机制处理 seek
   - 漂移过大时重置 frame_timer
   - 暂停恢复时补偿时间差

